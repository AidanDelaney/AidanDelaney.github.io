<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="author" content="Aidan Delaney">
  <title>What is HTTP?</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="reveal.js/css/reveal.css">
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="reveal.js/css/theme/white.css" id="theme">
  <!-- Printing and PDF exports -->
  <script>
    var link = document.createElement( 'link' );
    link.rel = 'stylesheet';
    link.type = 'text/css';
    link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
    document.getElementsByTagName( 'head' )[0].appendChild( link );
  </script>
  <!--[if lt IE 9]>
  <script src="reveal.js/lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>
  <div class="reveal">
    <div class="slides">

<section>
  <h1 class="title">What is HTTP?</h1>
  <p class="author">Aidan Delaney</p>
  <p class="date"><a href="mailto:aidan@ontologyengineering.org">aidan@ontologyengineering.org</a> | <a href="http://www.twitter.com/aidandelaney">@aidandelaney</a></p>
</section>
<section id="TOC">
<ul>
<li><a href="#/introduction">Introduction</a></li>
<li><a href="#/three-tier-architecture.">Three-tier Architecture.</a></li>
<li><a href="#/http">HTTP</a></li>
<li><a href="#/response">Response</a></li>
<li><a href="#/requestresponse">Request/Response</a></li>
<li><a href="#/conclusion">Conclusion</a></li>
</ul>
</section>

<section><section id="introduction" class="titleslide slide level1"><h1>Introduction</h1></section><section id="learning-objective" class="slide level2">
<h2>Learning Objective</h2>
<ul>
<li>Introduce 3-tier architecture.</li>
<li>Detail the process of DNS and HTTP.</li>
<li>Look at HTTP headers.</li>
</ul>
</section></section>
<section><section id="three-tier-architecture." class="titleslide slide level1"><h1>Three-tier Architecture.</h1></section><section id="section" class="slide level2">
<h2></h2>
<p>Web applications commonly have three tiers to their architecture:</p>
<ul>
<li>Presentation layer</li>
<li>Business logic layer</li>
<li>Storage layer</li>
</ul>
</section><section id="example-lamp" class="slide level2">
<h2>Example: LAMP</h2>
<p>In this case, the <em>L</em> is irrelevant:</p>
<ul>
<li>Presentation layer: HTML, images and CSS generated by PHP, served by Apache</li>
<li>Business logic layer: PHP functions</li>
<li>Storage layer: MySql</li>
</ul>
</section><section id="storage-layer-options" class="slide level2">
<h2>Storage Layer Options</h2>
<ul>
<li>Relational
<ul>
<li>MySql/MariaDB/Amazon RDS</li>
<li>Postgres</li>
<li>Microsoft SQL</li>
</ul></li>
<li>NoSql
<ul>
<li>Mongo</li>
<li>CouchDB</li>
</ul></li>
<li>RDF
<ul>
<li>Jena TDB</li>
<li>StarDog</li>
</ul></li>
</ul>
</section><section id="business-logic-options" class="slide level2">
<h2>Business Logic Options</h2>
<ul>
<li>PHP
<ul>
<li><a href="https://laravel.com/">Laravel</a></li>
<li><a href="https://symfony.com/">Symfony</a></li>
</ul></li>
<li>Java
<ul>
<li>J2EE</li>
<li><a href="https://spring.io/">Spring</a> -- note it's mostly J2EE compliant. eg: <a href="https://content.pivotal.io/case-studies">Case Studies</a></li>
</ul></li>
<li>.Net
<ul>
<li><a href="https://www.asp.net/">ASP.Net</a> eg: <a href="https://cyclr.com/">Cyclr</a></li>
</ul></li>
<li>Haskell
<ul>
<li>Yesod</li>
<li>Happstack</li>
</ul></li>
</ul>
</section><section id="presentation-layer-options" class="slide level2">
<h2>Presentation Layer Options</h2>
<ul>
<li>HTML &amp; CSS -- the old favourites</li>
<li>ReactJS</li>
<li>Ember</li>
<li>AngularJS</li>
</ul>
</section><section id="our-stack" class="slide level2">
<h2>Our Stack</h2>
<ol type="1">
<li>ReactJS</li>
<li>Spring framework on Wildfly</li>
<li>JPA on Postgres</li>
</ol>
</section><section id="modified-3-tier" class="slide level2">
<h2>Modified 3 tier</h2>
<ol type="1">
<li>ReactJS &quot;Application&quot;</li>
<li>Wildfly J2EE container</li>
<li>Spring framework business logic</li>
<li>JPA Object Relational Mapper</li>
<li>Postgres</li>
</ol>
</section></section>
<section><section id="http" class="titleslide slide level1"><h1>HTTP</h1></section><section id="section-1" class="slide level2">
<h2></h2>
<p>At the core of web work is the HTTP standard. There are three versions worth considering:</p>
<ul>
<li>HTTP 1.1 -- what everyone was using.</li>
<li>HTTP 2.0 -- what everyone is using.</li>
</ul>
</section><section id="protocol" class="slide level2">
<h2>Protocol</h2>
<ul>
<li>HTTP is a stateless protocol.
<ul>
<li>it does not remember the last time you visited a site.</li>
</ul></li>
<li>Allows <em>GET</em>, <em>POST</em>, <em>PUT</em> and <em>DELETE</em> amongst other operations.</li>
<li>Described in documents called &quot;RFCs&quot; or &quot;Request for Comments&quot;
<ul>
<li><a href="https://tools.ietf.org/html/rfc7230">rfc7230</a> HTTP 1.1 Message Syntax &amp; Routing</li>
<li><a href="https://tools.ietf.org/html/rfc7231">rfc7231</a> HTTP 1.1 Semantics &amp; Content</li>
<li>You need to be able to read RFCs!</li>
</ul></li>
</ul>
</section><section id="browser-example" class="slide level2">
<h2>Browser Example</h2>
<ol type="1">
<li>Type <a href="http://www.google.com" class="uri">http://www.google.com</a> into a web browser.</li>
<li><a href="http://www.google.com">www.google.com</a> is resolved to the IP address 216.58.208.164 (or similar)</li>
<li>The browser connects to port 80 on 216.58.208.164. Port 80 is the well-known http port.</li>
<li>Browser issues <code>GET</code> request for <code>/</code></li>
<li>Server -- in this case -- returns a HTTP status code <code>302</code>.</li>
</ol>
</section><section id="http-headers" class="slide level2">
<h2>HTTP Headers</h2>
<p>So what's in a HTTP message to <a href="http://www.google.com" class="uri">http://www.google.com</a>?</p>
<pre><code>GET / HTTP/1.1
Host: www.google.com
User-Agent: curl/7.51.0
Accept: */*</code></pre>
<p>Quite simply, it's 4 lines of text.</p>
</section><section id="get" class="slide level2">
<h2>GET</h2>
<p>A HTTP <code>GET</code> request asks for a specific resource.</p>
<pre><code>GET / HTTP/1.1</code></pre>
<p>In this case the resource is <code>/</code> over protocol <code>HTTP/1.1</code>.</p>
</section><section id="host" class="slide level2">
<h2>Host</h2>
<pre><code>Host: www.google.com</code></pre>
<p>&quot;The 'Host' header field in a request provides the host and port information from the target URI, enabling the origin server to distinguish among resources while servicing requests for multiple host names on a single IP address.&quot; <a href="https://tools.ietf.org/html/rfc7230#section-5.4">RFC7230</a></p>
</section><section id="user-agent" class="slide level2">
<h2>User-Agent</h2>
<p>The User-Agent header identifies the caller.</p>
<pre><code>User-Agent: curl/7.51.0</code></pre>
<p>&quot; The 'User-Agent' header field contains information about the user agent originating the request, which is often used by servers to help identify the scope of reported interoperability problems, to work around or tailor responses to avoid particular user agent limitations, and for analytics regarding browser or operating system use. A user agent SHOULD send a User-Agent field in each request unless specifically configured not to do so. &quot; <a href="https://tools.ietf.org/html/rfc7231#section-5.5.3">RFC7231</a></p>
</section><section id="accept" class="slide level2">
<h2>Accept</h2>
<pre><code>Accept: */*</code></pre>
<p>&quot; The '<a href="https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/">Accept</a>' header field can be used by user agents to specify response media types that are acceptable. Accept header fields can be used to indicate that the request is specifically limited to a small set of desired types, as in the case of a request for an in-line image. &quot;</p>
</section></section>
<section><section id="response" class="titleslide slide level1"><h1>Response</h1></section><section id="http-status-codes" class="slide level2">
<h2>HTTP Status Codes</h2>
<ul>
<li>1xx Informational.</li>
<li>2xx Success.</li>
<li>3xx Redirection.</li>
<li>4xx Client Error.</li>
<li>5xx Server Error.</li>
</ul>
<p>In this case we got a <code>302</code>.</p>
<p>&quot; The 302 (Found) status code indicates that the target resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client ought to continue to use the effective request URI for future requests.&quot; <a href="https://tools.ietf.org/html/rfc7231#page-56">RFC7231</a></p>
</section></section>
<section><section id="requestresponse" class="titleslide slide level1"><h1>Request/Response</h1></section><section id="section-2" class="slide level2">
<h2></h2>
<ul>
<li>Every HTTP request generates are response, or a time out.</li>
<li>Most web frameworks give you direct access to a representation of the HTTP Request that has been sent.</li>
<li>Your job in the business logic, is to build an appropriate HTTP Response.</li>
</ul>
</section><section id="section-3" class="slide level2">
<h2></h2>
<p>We've seen the HTTP <code>GET</code> request. What are the important other request verbs?</p>
<ul>
<li>GET -- see <a href="https://tools.ietf.org/html/rfc7231#section-4.3.1">RFC7231 Section 4.3.1</a></li>
<li>POST -- see <a href="https://tools.ietf.org/html/rfc7231#section-4.3.3">RFC7231 Section 4.3.3</a></li>
<li>PUT -- see <a href="https://tools.ietf.org/html/rfc7231#section-4.3.4">RFC7231 Section 4.3.4</a></li>
<li>DELETE -- see <a href="https://tools.ietf.org/html/rfc7231#section-4.3.5">RFC7231 Section 4.3.5</a></li>
</ul>
<p>Note that the RFCs are the <em>primary</em> definition. That's why we refer to them.</p>
</section><section id="request-body" class="slide level2">
<h2>Request Body</h2>
<p>The request body is separated from the headers using <code>\n\r</code>. Like the headers, it is delivered as a stream of bytes. It is interpreted according to the content-type and encoding in the headers.</p>
</section><section id="request-body-eg" class="slide level2">
<h2>Request Body Eg</h2>
<p>Example POST request with JSON body (we'll cover JSON later).</p>
<pre><code>POST / HTTP/1.1
Host: www.brighton.ac.uk
User-Agent: curl/7.51.0
Accept: */*
Content-type: application/json
Content-Length: 18

{
    &quot;example&quot;: 1
}</code></pre>
</section><section id="response-body" class="slide level2">
<h2>Response Body</h2>
<p>The response also has a body. Often this is HTML content!</p>
</section></section>
<section><section id="conclusion" class="titleslide slide level1"><h1>Conclusion</h1></section><section id="section-4" class="slide level2">
<h2></h2>
<ul>
<li>The HTTP verbs are key to understanding what is going on in web requests.</li>
<li><code>Content-type</code> and <code>Accept</code> headers are important as they lead to issues in understanding routing.</li>
<li>We will find the request/response abstraction is built into <em>many</em> web frameworks.</li>
<li>No-one uses <code>http://</code> anymore. Go <code>https://</code> or go home!</li>
</ul>
</section></section>
    </div>
  </div>

  <script src="reveal.js/lib/js/head.min.js"></script>
  <script src="reveal.js/js/reveal.js"></script>

  <script>

      // Full list of configuration options available at:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        // Transition style
        transition: 'linear', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
          { src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
              { src: 'reveal.js/plugin/notes/notes.js', async: true }
        ]
      });
    </script>
    </body>
</html>
